---
title: "Modeling gradable adjectives"
bibliography: ../../pds.bib
format:
  html:
    css: ../styles.css
    html-math-method: mathjax
    mathjax-config:
      loader: {load: ['[tex]/bussproofs','[tex]/bbox','[tex]/colorbox']}
      tex:
        packages: {'[+]': ['bussproofs','bbox','colorbox']}
---

::: {.hidden}
$$
\newcommand{\expr}[3]{\begin{array}{c}
#1 \\
\bbox[lightblue,5px]{#2}
\end{array} ⊢ #3}
\newcommand{\ct}[1]{\bbox[font-size: 0.8em]{\mathsf{#1}}}
\newcommand{\updct}[1]{\ct{upd\_#1}}
\newcommand{\abbr}[1]{\bbox[transform: scale(0.95)]{\mathtt{#1}}}
\newcommand{\pure}[1]{\bbox[border: 1px solid orange]{\bbox[border: 4px solid transparent]{#1}}}
\newcommand{\return}[1]{\bbox[border: 1px solid black]{\bbox[border: 4px solid transparent]{#1}}}
\def\P{\mathtt{P}}
\def\Q{\mathtt{Q}}
\def\True{\ct{T}}
\def\False{\ct{F}}
\def\ite{\ct{if\_then\_else}}
\def\Do{\abbr{do}}
$$
:::

To understand how Stan works and how we can use it to test semantic theories, let's work through three models of increasing complexity. We'll start with a baseline norming model that will serve as our introduction to Stan's structure and syntax. Each model will demonstrate how PDS translates semantic theory into statistical kernels, which we then augment for real-world data analysis.

## The PDS implementation: Gradable adjectives

Before diving into Stan code, let's examine how gradable adjectives are represented in PDS. From the Haskell codebase ([`Grammar.Lexica.SynSem.Adjectives`](https://juliangrove.github.io/pds/Grammar-Lexica-SynSem-Adjectives.html)), here's the lexical entry for "tall":

```haskell
"tall" -> [ SynSem {
    syn = AP,
    sem = ty tau (lam s (purePP (lam x (lam i 
      (sCon "(≥)" @@ (sCon "height" @@ i @@ x) @@ 
       (sCon "d_tall" @@ s))))) @@ s))
} ]
```

This Haskell implementation directly encodes the formal semantics $⟦\text{tall}⟧$ presented in the previous section. The key components map as follows:
- `sCon "height"` implements the measure function
- `sCon "d_tall"` extracts the contextual threshold from the discourse state
- `sCon "(≥)"` implements the comparison relation
- The lambda abstractions mirror the semantic type $(e → (i → t))$

This lexical entry encodes several key theoretical insights:

1. **Syntactic type**: `AP` indicates this is an adjective phrase
2. **Semantic computation**: The meaning is a function that:
   - Takes a discourse state `s` (containing threshold information)
   - Returns a function from entities `x` to propositions (functions from indices `i` to truth values)
   - The proposition is true when the entity's height exceeds the contextual threshold

3. **Semantic components**:
   - $\ct{height}$: A function from indices to entity-to-degree mappings (type: $\iota \to e \to r$)
   - $\ct{d\_tall}$: Extracts the threshold for "tall" from the discourse state (type: $\sigma \to r$)
   - $\ct{(≥)}$: Comparison operator (type: $r \to r \to t$)

This implements @kennedy_vagueness_2007's degree-based semantics, where gradable adjectives denote relations between degrees and contextually determined thresholds. The use of the discourse state for threshold storage captures the context-sensitivity of standards.