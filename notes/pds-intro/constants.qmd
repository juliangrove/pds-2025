---
title: "Constants"
bibliography: ../../pds.bib
format:
  html:
    css: ../styles.css
    html-math-method: mathjax
    mathjax-config:
      loader: {load: ['[tex]/bussproofs','[tex]/bbox','[tex]/colorbox']}
      tex:
        packages: {'[+]': ['bussproofs','bbox','colorbox']}
---

::: {.hidden}
$$
\newcommand{\expr}[3]{\begin{array}{c}
#1 \\
\bbox[lightblue,5px]{#2}
\end{array} âŠ¢ #3}
\newcommand{\ct}[1]{\bbox[font-size: 0.8em]{\mathsf{#1}}}
\newcommand{\updct}[1]{\ct{upd\_#1}}
\newcommand{\abbr}[1]{\bbox[transform: scale(0.95)]{\mathtt{#1}}}
\newcommand{\pure}[1]{\bbox[border: 1px solid orange]{\bbox[border: 4px solid transparent]{#1}}}
\newcommand{\return}[1]{\bbox[border: 1px solid black]{\bbox[border: 4px solid transparent]{#1}}}
\def\P{\mathtt{P}}
\def\Q{\mathtt{Q}}
\def\True{\ct{T}}
\def\False{\ct{F}}
\def\ite{\ct{if\_then\_else}}
\def\Do{\abbr{do}}
$$
:::

Here we provide a bit more information about the types of constants, as they are encoded in Haskell.
The constants provided here are not exhaustive, but it should be more or less clear from these examples how to generalize the typing scheme to others.

### Logical constants

First, it is useful to have logical constants (e.g., to encode basic meanings for things):

```haskell
-- | Logical constants.
tauLogical :: Sig
tauLogical = \case
  Left "âˆ€"   -> Just ((Î± :â†’ t) :â†’ t)
  Left "âˆƒ"   -> Just ((Î± :â†’ t) :â†’ t)
  Left "(âˆ§)" -> Just (t :â†’ t :â†’ t)
  Left "(âˆ¨)" -> Just (t :â†’ t :â†’ t)
  Left "(â‡’)" -> Just (t :â†’ t :â†’ t)
  Left "Â¬"   -> Just (t :â†’ t)
  Left "T"   -> Just t
  Left "F"   -> Just t
  _          -> Nothing
```

Note that the universal and existential quantifiers are typed to be polymorphic in the variable they quantify over.

### Non-logical constants

Second, non-logical constants, e.g., $\ct{ling}$, $\ct{j}$, etc.:

```haskell
-- | Some non-logical constants.
tauNonLogical :: Sig
tauNonLogical = \case
  Left "upd_ling" -> Just ((e :â†’ t) :â†’ Î¹ :â†’ Î¹)
  Left "ling"     -> Just (Î¹ :â†’ e :â†’ t)
  Left "j"        -> Just e
  Left "b"        -> Just e
  Left "@"        -> Just Î¹ -- the starting index
  _               -> Nothing
```

Following the discussion [here](#the-common-ground), constants which are intensional have corresponding constants for updating their values.

### Metalinguistc parameters

Following the disccusion [here](#states), we should encode constants that access metalinguistic parameters, i.e., components of the state:

```haskell
-- | Some metalinguistic parameters.
tauMetalinguistic :: Sig
tauMetalinguistic = \case
  Left "upd_CG"  -> Just (P Î¹ :â†’ Ïƒ :â†’ Ïƒ)
  Left "CG"      -> Just (Ïƒ :â†’ P Î¹)
  Left "upd_QUD" -> Just ((Îº :â†’ Î¹ :â†’ t) :â†’ Ïƒ :â†’ Q Î¹ Îº Ïƒ)
  Left "QUD"     -> Just (Q Î¹ Îº Ïƒ :â†’ Îº :â†’ Î¹ :â†’ t)
  Left "Ïµ"       -> Just Ïƒ -- the starting state
  _              -> Nothing
```

### "Built-in" distributions

Some constants can be used to represent probability (e.g., Bernoulli and normal) distributions, and standard ways of manipulating them:

```haskell
-- | Some probability distributions (and certain ways of manipulating them).
tauDistributions ::Sig
tauDistributions = \case
  Left "Bernoulli" -> Just (r :â†’ P t)
  Left "Normal"    -> Just (r :Ã— r :â†’ P r)
  Left "Truncate"  -> Just (r :Ã— r :â†’ P r :â†’ P r)
  Left "#"         -> Just (P Î±) -- undefined distributions
  _                -> Nothing
```

The third constant, for example, can be used to represent the truncation of some distribution to values within a specified range.
Note also the fourth constant, which encodes "undefined" probability distributions.

### Computing with numbers and truth values

Other constants can be used to do computations with, e.g., truth values and real numbers:

```haskell
-- | Some basic data types (e.g., truth values and reals) and ways of computing with them.
tauBasicStuff :: Sig
tauBasicStuff = \case
  Left  "if_then_else" -> Just (t :Ã— Î± :Ã— Î± :â†’ Î±) -- compute /if then else/
  Left  "ðŸ™"            -> Just (t :â†’ r)           -- the indicator function
  Left  "mult"         -> Just (r :Ã— r :â†’ r)      -- multiply two numbers
  Left  "add"          -> Just (r :Ã— r :â†’ r)      -- add two numbers
  Left  "neg"          -> Just (r :â†’ r)           -- add a minus sign
  Left  "(â‰¥)"          -> Just (r :â†’ r :â†’ t)      -- compare two numbers
  Left  "max"          -> Just ((r :â†’ t) :â†’ r)    -- take the maximum number from a set
  Right _              -> Just r                  -- real numbers are constants
  _                    -> Nothing
```

### More probabilistic stuff

Other constants for, e.g., factoring, making observations, and computing probabilities.

```haskell
-- | The probability operator, /factor/, and /observe/.
tauProbabilities :: Sig
tauProbabilities = \case
  Left "Pr"      -> Just (P t :â†’ r)
  Left "factor"  -> Just (r :â†’ P Unit)
  Left "observe" -> Just (t :â†’ P Unit)
  _              -> Nothing
```

### Combining signatures

It would be convenient to have a way, given any two signatures, to combine them.
In Haskell, we can accomplish this with the following function that combines values inhabiting types that instantiate the [`Alternative`](https://hackage.haskell.org/package/monadplus-1.4.3/docs/Control-Applicative-Alternative.html) class:

```haskell
(<||>) :: Alternative m => (a -> m b) -> (a -> m b) -> a -> m b
f <||> g = \x -> f x <|> g x
```

Because `Maybe` is an instance of `Alternative`, we can combine signatures using such a function.
For example, if we want to combine the signature `tauLogical` with the signature `tauNonLogical`, we can do:

```haskell
tauLogicalNonLogical :: Sig
tauLogicalNonLogical = tauLogical <||> tauNonLogical
```

Indeed, we can combine as many signatures as we want in this way, using `(<||>)`.
The resulting signature will type all of the constants that the component signatures type, with signatures listed further to the left taking precedence in case there is any overlap.